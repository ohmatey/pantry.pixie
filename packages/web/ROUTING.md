# File-Based Routing Guide

Pantry Pixie now uses **Next.js-style file-based routing** while maintaining SPA architecture for offline-first PWA benefits.

## ğŸ“ Directory Structure

```
src/client/pages/
â”œâ”€â”€ login.tsx              â†’ /login
â”œâ”€â”€ register.tsx           â†’ /register
â”œâ”€â”€ onboarding.tsx         â†’ /onboarding (with AuthGuard)
â”œâ”€â”€ invite/
â”‚   â””â”€â”€ [code].tsx         â†’ /invite/:code (dynamic route)
â””â”€â”€ (app)/                 â†’ route group (doesn't affect URL)
    â”œâ”€â”€ chat.tsx           â†’ /chat
    â”œâ”€â”€ list.tsx           â†’ /list
    â””â”€â”€ settings.tsx       â†’ /settings
```

## ğŸ¯ Routing Conventions

### Basic Routes

- **File name = Route path**
  - `login.tsx` â†’ `/login`
  - `chat.tsx` â†’ `/chat`

### Dynamic Routes

- **Square brackets = URL parameters**
  - `[code].tsx` â†’ `/:code`
  - `[id].tsx` â†’ `/:id`

### Route Groups

- **Parentheses = organizational grouping (no URL impact)**
  - `(app)/chat.tsx` â†’ `/chat` (NOT `/app/chat`)
  - Use for grouping related routes with shared layouts/guards

## âœ… Benefits Over Manual React Router

### Before (Manual React Router)

```tsx
// App.tsx - 50+ lines of route definitions
<Routes>
  <Route path="/login" element={<LoginPage />} />
  <Route path="/register" element={<RegisterPage />} />
  <Route
    path="/onboarding"
    element={
      <AuthGuard>
        <OnboardingPage />
      </AuthGuard>
    }
  />
  <Route path="/invite/:code" element={<AcceptInvitePage />} />
  <Route
    element={
      <AuthGuard>
        <OnboardingGuard>
          <AppShell />
        </OnboardingGuard>
      </AuthGuard>
    }
  >
    <Route path="/chat" element={<ChatPage />} />
    <Route path="/list" element={<ListPage />} />
    <Route path="/settings" element={<SettingsPage />} />
  </Route>
  <Route path="*" element={<Navigate to="/chat" replace />} />
</Routes>
```

### After (File-Based Routing)

```tsx
// App.tsx - 3 lines!
const routes = generateRoutes();
<Routes>{renderRoutes(routes)}</Routes>;
```

## ğŸš€ How It Works

1. **Route Generator** (`lib/route-generator.tsx`):
   - Lazy-loads all page components
   - Wraps routes with guards (AuthGuard, OnboardingGuard)
   - Applies layouts (AppShell)
   - Adds Suspense with loading fallbacks

2. **Page Components**:
   - Must use **default exports** (for React.lazy)
   - Automatically wrapped in Suspense
   - Guards and layouts applied via route config

3. **App.tsx**:
   - Calls `generateRoutes()` to get config
   - Uses `renderRoutes()` to create `<Route>` elements

## ğŸ“ Adding New Routes

### Example: Add `/profile` page

1. Create file:

   ```bash
   touch src/client/pages/(app)/profile.tsx
   ```

2. Write component:

   ```tsx
   // pages/(app)/profile.tsx
   export default function ProfilePage() {
     return <div>Profile Page</div>;
   }
   ```

3. Update route generator:

   ```tsx
   // lib/route-generator.tsx
   const ProfilePage = lazy(() => import("../pages/(app)/profile"));

   // Add to children array:
   children: [
     { path: "chat", element: withSuspense(ChatPage) },
     { path: "list", element: withSuspense(ListPage) },
     { path: "settings", element: withSuspense(SettingsPage) },
     { path: "profile", element: withSuspense(ProfilePage) }, // â† Add here
   ];
   ```

4. Done! Route is live at `/profile`

## ğŸ¨ Why This Approach?

### âœ… Keeps SPA Benefits

- **Offline-first**: Entire app cached by service worker
- **Fast navigation**: Client-side routing (no server round-trip)
- **PWA-friendly**: Works perfectly with IndexedDB and offline queue

### âœ… Next.js-Style DX

- **File-based routes**: Route structure matches file structure
- **Automatic code-splitting**: Each page is a separate chunk
- **Lazy loading**: Pages load on-demand
- **Clean codebase**: No manual route definitions

### âŒ Why Not Bun's File-System Router?

Bun's file-system router requires **server-side rendering (SSR)**, which conflicts with offline-first PWA architecture:

- SSR needs server connection (bad for offline)
- Complex offline fallback handling required
- Loses service worker caching benefits
- Our approach gives 80% of Next.js DX without SSR complexity

## ğŸ”§ Maintenance

### Updating Routes

1. Edit `lib/route-generator.tsx` to add/remove routes
2. Follow existing patterns (lazy loading + Suspense)
3. Apply guards/layouts as needed

### Future Enhancement

Could automate route generation by scanning `pages/` directory at build time, similar to Next.js. For now, manual config in `route-generator.tsx` provides explicit control with minimal overhead.

## ğŸ¯ Summary

**Before**: 50+ lines of React Router boilerplate in App.tsx
**After**: File-based structure + 3-line route rendering
**Result**: Clean Next.js-style DX + full offline PWA capabilities

---

_Generated by Pantry Pixie routing migration (2026-02-15)_
